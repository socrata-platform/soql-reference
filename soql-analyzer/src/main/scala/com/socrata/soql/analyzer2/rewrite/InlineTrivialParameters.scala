package com.socrata.soql.analyzer2.rewrite

import com.socrata.soql.analyzer2
import com.socrata.soql.analyzer2._
import com.socrata.soql.collection._
import com.socrata.soql.environment.ResourceName

class InlineTrivialParameters[MT <: MetaTypes] private (isLiteralTrue: Expr[MT] => Boolean) extends StatementUniverse[MT] {
  // This pass inlines trivial parameters in subqueries shaped like
  // those generated by UDFS.  In particular, if we find a subselect
  // that looks like
  //
  // SELECT t2.* FROM (VALUES ((...))) t1 JOIN LATERAL (select ... ) as t2 on true
  //
  // then we'll walk the t2 tree substituting in references to t1
  // which are exactly columnref or literals, and if that's _all_ the
  // values in the VALUES clause, we'll eliminate this outer select
  // entirely in favor of the inner one.

  type ExprReplaces = Map[(AutoTableLabel, AutoColumnLabel), Expr]

  private def matchingSelects(outerSelectList: OrderedMap[AutoColumnLabel, NamedExpr], innerSelectList: OrderedMap[AutoColumnLabel, NameEntry[CT]], innerLabel: AutoTableLabel): Boolean = {
    if(outerSelectList.size != innerSelectList.size) {
      return false
    }

    outerSelectList.iterator.zip(innerSelectList.iterator).forall { case ((_, e), (c, cExpr)) =>
      e.expr match {
        case VirtualColumn(tbl, col, typ) if tbl == innerLabel && col == c =>
          assert(typ == cExpr.typ)
          true
        case _ =>
          false
      }
    }
  }

  private class Candidate(
    val selectList: OrderedMap[AutoColumnLabel, NamedExpr],
    val valuesColumnLabels: OrderedSet[AutoColumnLabel],
    val valuesExprs: NonEmptySeq[Expr],
    val valuesLabel: AutoTableLabel,
    val subselect: Statement,
    val subselectLabel: AutoTableLabel,
    val trueExpr: Expr
  )

  private object Candidate {
    def unapply(s: Select): Option[Candidate] = {
      s match {
        case Select(
          Distinctiveness.Indistinct(),
          selectList,
          Join(
            JoinType.Inner,
            true,
            FromStatement(
              values: Values,
              valuesLabel,
              None,
              None
            ),
            FromStatement(
              subselect,
              subselectLabel,
              None,
              None
            ),
            on
          ),
          None,
          Nil,
          None,
          Nil,
          None,
          None,
          None,
          hint
        ) if hint.isEmpty && isLiteralTrue(on) && matchingSelects(selectList, subselect.schema, subselectLabel) && values.values.tail.isEmpty =>
          Some(new Candidate(selectList, values.labels, values.values.head, valuesLabel, subselect, subselectLabel, on))
        case _ =>
          None
      }
    }
  }

  private def isTrivial(e: Expr): Boolean =
    e match {
      case _ : Column => true
      case _ : Literal => true
      case _ => false
    }

  def rewriteStatement(stmt: Statement, exprReplaces: ExprReplaces): Statement = {
    stmt match {
      case CombinedTables(op, left, right) =>
        CombinedTables(op, rewriteStatement(left, exprReplaces), rewriteStatement(right, exprReplaces))
      case CTE(defLabel, defAlias, defQuery, matHint, useQuery) =>
        CTE(defLabel, defAlias, rewriteStatement(defQuery, exprReplaces), matHint, rewriteStatement(useQuery, exprReplaces))
      case v@Values(_, _) =>
        v
      case s: Select =>
        rewriteSelect(s, exprReplaces)
    }
  }

  def rewriteSelect(select: Select, exprReplaces: ExprReplaces): Statement = {
    select match {
      case Candidate(c) =>
        // Ok, it's shaped right for this optimization.

        def selectList = c.selectList
        def valuesLabel = c.valuesLabel
        def valuesColumnLabels = c.valuesColumnLabels
        // The `values` forms exprs, have not been remapped, so do so now
        val valuesExprs = c.valuesExprs.map(rewriteExpr(_, exprReplaces))
        def subselect = c.subselect
        def subselectLabel = c.subselectLabel
        def trueExpr = c.trueExpr

        // Now we'll augment our replaces with the trivial ones from
        // the values...
        val newExprReplaces = exprReplaces ++ valuesColumnLabels.iterator.zip(valuesExprs.iterator).collect { case (l, e) if isTrivial(e) =>
          (valuesLabel, l) -> e
        }

        // ..and use that to rewrite the subselect.
        val newSubselect = rewriteStatement(subselect, newExprReplaces)
        assert(newSubselect.schema.size == selectList.size)

        // We'll only be keeping columns in the `values` form which
        // weren't trivial.
        val (newValuesLabels, newValuesExprs) = valuesColumnLabels.iterator.zip(valuesExprs.iterator).filter { case (l, e) =>
          !isTrivial(e)
        }.toSeq.unzip

        NonEmptySeq.fromSeq(newValuesExprs) match {
          case None =>
            // We'll be removing this outer selection entirely, so
            // we'll want to do some relabelling - specifically, we'll
            // be relabelling the inner subselect's columns to use the
            // outer select's labels.
            val newLabels = OrderedMap() ++ newSubselect.schema.iterator.zip(selectList.iterator).map { case ((oldLabel, ent), (correctedLabel, expr)) =>
              assert(expr.expr.typ == ent.typ)
              oldLabel -> correctedLabel
            }
            rewriteOutputSchemaLabels(newSubselect, newLabels)
          case Some(newValuesExprs) =>
            Select(
              Distinctiveness.Indistinct(),
              selectList,
              Join(
                JoinType.Inner,
                true,
                FromStatement(
                  Values(OrderedSet() ++ newValuesLabels, NonEmptySeq(newValuesExprs, Nil)),
                  valuesLabel,
                  None,
                  None
                ),
                FromStatement(
                  newSubselect,
                  subselectLabel,
                  None,
                  None
                ),
                trueExpr
              ),
              None,
              Nil,
              None,
              Nil,
              None,
              None,
              None,
              Set.empty
            )
        }
      case Select(
        distinctiveness,
        selectList,
        from,
        where,
        groupBy,
        having,
        orderBy,
        limit,
        offset,
        search,
        hint
      ) =>
        Select(
          rewriteDistinctiveness(distinctiveness, exprReplaces),
          selectList.withValuesMapped { ne => ne.copy(expr = rewriteExpr(ne.expr, exprReplaces)) },
          rewriteFrom(from, exprReplaces),
          where.map(rewriteExpr(_, exprReplaces)),
          groupBy.map(rewriteExpr(_, exprReplaces)),
          having.map(rewriteExpr(_, exprReplaces)),
          orderBy.map(rewriteOrderBy(_, exprReplaces)),
          limit,
          offset,
          search,
          hint
        )
    }
  }

  def rewriteOutputSchemaLabels(statement: Statement, map: Map[AutoColumnLabel, AutoColumnLabel]): Statement = {
    statement match {
      case s: Select =>
        s.copy(selectList = OrderedMap() ++ s.selectList.iterator.map { case (oldLabel, expr) => map(oldLabel) -> expr })
      case v: Values =>
        v.copy(labels = OrderedSet() ++ v.labels.iterator.map { oldLabel => map(oldLabel) })
      case cte: CTE =>
        cte.copy(useQuery = rewriteOutputSchemaLabels(cte.useQuery, map))
      case ct: CombinedTables =>
        ct.copy(left = rewriteOutputSchemaLabels(ct.left, map))
    }
  }

  def rewriteDistinctiveness(distinctiveness: Distinctiveness, exprReplaces: ExprReplaces): Distinctiveness =
    distinctiveness match {
      case Distinctiveness.Indistinct() | Distinctiveness.FullyDistinct() => distinctiveness
      case Distinctiveness.On(exprs) => Distinctiveness.On(exprs.map(rewriteExpr(_, exprReplaces)))
    }

  def rewriteFrom(from: From, exprReplaces: ExprReplaces): From =
    from.map[MT](
      rewriteAtomicFrom(_, exprReplaces),
      { (joinType, lateral, left, right, on) =>
        Join(joinType, lateral, left, rewriteAtomicFrom(right, exprReplaces), rewriteExpr(on, exprReplaces))
      }
    )

  def rewriteAtomicFrom(from: AtomicFrom, exprReplaces: ExprReplaces): AtomicFrom =
    from match {
      case t: FromTable => t
      case sr: FromSingleRow => sr
      case FromStatement(stmt, label, rn, alias) => FromStatement(rewriteStatement(stmt, exprReplaces), label, rn, alias)
    }

  def rewriteExpr(expr: Expr, exprReplaces: ExprReplaces): Expr =
    expr match {
      case vc@VirtualColumn(table, column, typ) =>
        exprReplaces.get((table, column)) match {
          case Some(replacement) =>
            assert(replacement.typ == typ)
            replacement
          case None =>
            vc
        }
      case pt: PhysicalColumn =>
        pt
      case slr: SelectListReference =>
        slr
      case lit: Literal =>
        lit
      case fc@FunctionCall(func, args) =>
        FunctionCall(func, args.map(rewriteExpr(_, exprReplaces)))(fc.position)
      case afc@AggregateFunctionCall(func, args, distinct, filter) =>
        AggregateFunctionCall(
          func,
          args.map(rewriteExpr(_, exprReplaces)),
          distinct,
          filter.map(rewriteExpr(_, exprReplaces))
        )(afc.position)
      case wfc@WindowedFunctionCall(func, args, filter, partitionBy, orderBy, frame) =>
        WindowedFunctionCall(
          func,
          args.map(rewriteExpr(_, exprReplaces)),
          filter.map(rewriteExpr(_, exprReplaces)),
          partitionBy.map(rewriteExpr(_, exprReplaces)),
          orderBy.map(rewriteOrderBy(_, exprReplaces)),
          frame
        )(wfc.position)
    }

  def rewriteOrderBy(ob: OrderBy, exprReplaces: ExprReplaces) =
    ob.copy(expr = rewriteExpr(ob.expr, exprReplaces))
}

object InlineTrivialParameters {
  def apply[MT <: MetaTypes](isLiteralTrue: Expr[MT] => Boolean, stmt: Statement[MT]): Statement[MT] = {
    new InlineTrivialParameters[MT](isLiteralTrue).rewriteStatement(stmt, Map.empty)
  }
}
