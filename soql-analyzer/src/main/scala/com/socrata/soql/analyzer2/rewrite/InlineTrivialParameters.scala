package com.socrata.soql.analyzer2.rewrite

import scala.collection.compat._

import com.socrata.soql.analyzer2
import com.socrata.soql.analyzer2._
import com.socrata.soql.collection._
import com.socrata.soql.environment.{ResourceName, ColumnName}

class InlineTrivialParameters[MT <: MetaTypes] private (isLiteralTrue: Expr[MT] => Boolean) extends StatementUniverse[MT] {
  // This pass inlines trivial parameters in subqueries shaped like
  // those generated by UDFS.  In particular, if we find a subselect
  // that looks like
  //
  // SELECT t2.* FROM (VALUES ((...))) t1 JOIN LATERAL (select ... ) as t2 on true
  // -or-
  // SELECT t2.* FROM (SELECT ... FROM @single_row) t1 JOIN LATERAL (select ... ) as t2 on true
  // where all the sub-selected values are "synthetic"
  //
  // then we'll walk the t2 tree substituting in references to t1
  // which are exactly columnref or literals, and if that's _all_ the
  // values in the VALUES/subselect clause, we'll eliminate this outer
  // select entirely in favor of the inner one.
  //
  // Note: currently the analyzer will always produce the subselect
  // form (formerly it would aways produce the VALUES) form, but until
  // soql grows VALUES surface syntax that's changed.  It will
  // hopefully go back the other way, someday, which is why this
  // understand both.

  type ExprReplaces = Map[(AutoTableLabel, AutoColumnLabel), Expr]

  private def matchingSelects(outerSelectList: OrderedMap[AutoColumnLabel, NamedExpr], innerSelectList: OrderedMap[AutoColumnLabel, Statement.SchemaEntry[MT]], innerLabel: AutoTableLabel): Boolean = {
    if(outerSelectList.size != innerSelectList.size) {
      return false
    }

    outerSelectList.iterator.zip(innerSelectList.iterator).forall { case ((_, e), (c, cExpr)) =>
      e.expr match {
        case VirtualColumn(tbl, col, typ) if tbl == innerLabel && col == c =>
          assert(typ == cExpr.typ)
          true
        case _ =>
          false
      }
    }
  }

  private class Candidate(
    val selectList: OrderedMap[AutoColumnLabel, NamedExpr],
    val values: OrderedMap[AutoColumnLabel, (Expr, ColumnName)],
    val singleRowFrom: Option[FromSingleRow],
    val valuesLabel: AutoTableLabel,
    val valuesSource: Option[ScopedResourceName],
    val valuesCanonicalName: Option[CanonicalName],
    val subselect: Statement,
    val subselectLabel: AutoTableLabel,
    val subselectSource: Option[ScopedResourceName],
    val subselectCanonicalName: Option[CanonicalName],
    val trueExpr: Expr
  )

  private object SingleRowValuesLike {
    def unapply(stmt: Statement): Option[(OrderedMap[AutoColumnLabel, (Expr, ColumnName)], Option[FromSingleRow])] =
      stmt match {
        case Values(labels, values) if values.tail.isEmpty =>
          Some((OrderedMap() ++ labels.iterator.zip(values.head.iterator).map { case (label, value) => label -> (value, stmt.schema(label).name) }, None))

        case Select(Distinctiveness.Indistinct(), selectList, from@FromSingleRow(_, _), None, Nil, None, Nil, None, None, None, hints) if hints.isEmpty && selectList.values.forall(_.isSynthetic) =>
          Some((selectList.withValuesMapped { ne => (ne.expr, ne.name) }, Some(from)))

        case _ =>
          None
      }
  }

  private object Candidate {
    def unapply(s: Select): Option[Candidate] = {
      s match {
        case Select(
          Distinctiveness.Indistinct(),
          selectList,
          Join(
            JoinType.Inner,
            true,
            FromStatement(
              SingleRowValuesLike(fields, singleRowFrom),
              valuesLabel,
              valuesSource,
              valuesCanonicalName,
              None
            ),
            FromStatement(
              subselect,
              subselectLabel,
              subselectSource,
              subselectCanonicalName,
              None
            ),
            on
          ),
          None,
          Nil,
          None,
          Nil,
          None,
          None,
          None,
          hint
        ) if hint.isEmpty && isLiteralTrue(on) && matchingSelects(selectList, subselect.schema, subselectLabel) =>
          Some(new Candidate(selectList, fields, singleRowFrom, valuesLabel, valuesSource, valuesCanonicalName, subselect, subselectLabel, subselectSource, subselectCanonicalName, on))
        case _ =>
          None
      }
    }
  }

  private def isTrivial(e: Expr): Boolean =
    e match {
      case _ : Column => true
      case _ : Literal => true
      case _ => false
    }

  def rewriteStatement(stmt: Statement, exprReplaces: ExprReplaces): Statement = {
    stmt match {
      case CombinedTables(op, left, right) =>
        CombinedTables(op, rewriteStatement(left, exprReplaces), rewriteStatement(right, exprReplaces))
      case CTE(defLabel, defAlias, defQuery, matHint, useQuery) =>
        CTE(defLabel, defAlias, rewriteStatement(defQuery, exprReplaces), matHint, rewriteStatement(useQuery, exprReplaces))
      case v@Values(_, _) =>
        v
      case s: Select =>
        rewriteSelect(s, exprReplaces)
    }
  }

  def rewriteSelect(select: Select, exprReplaces: ExprReplaces): Statement = {
    select match {
      case Candidate(c) =>
        // Ok, it's shaped right for this optimization.

        def selectList = c.selectList
        def valuesLabel = c.valuesLabel
        def valuesSource = c.valuesSource
        def valuesCanonicalName = c.valuesCanonicalName
        // The `values` forms exprs, have not been remapped, so do so now
        val values = c.values.withValuesMapped { case (e, name) => (rewriteExpr(e, exprReplaces), name) }
        def singleRowFrom = c.singleRowFrom
        def subselect = c.subselect
        def subselectLabel = c.subselectLabel
        def subselectSource = c.subselectSource
        def subselectCanonicalName = c.subselectCanonicalName
        def trueExpr = c.trueExpr

        // Now we'll augment our replaces with the trivial ones from
        // the values...
        val newExprReplaces = exprReplaces ++ values.iterator.collect { case (l, (e, _)) if isTrivial(e) =>
          (valuesLabel, l) -> e
        }

        // ..and use that to rewrite the subselect.
        val newSubselect = rewriteStatement(subselect, newExprReplaces)
        assert(newSubselect.schema.size == selectList.size)

        // We'll only be keeping columns in the `values` form which
        // weren't trivial.
        val (newValuesLabels, newValuesExprs) = values.filter { case (l, (e, _)) =>
          !isTrivial(e)
        }.toSeq.unzip

        NonEmptySeq.fromSeq(newValuesExprs) match {
          case None =>
            // We'll be removing this outer selection entirely, so
            // we'll want to do some relabelling - specifically, we'll
            // be relabelling the inner subselect's columns to use the
            // outer select's labels.
            val newLabels = OrderedMap() ++ newSubselect.schema.iterator.zip(selectList.iterator).map { case ((oldLabel, ent), (correctedLabel, expr)) =>
              assert(expr.expr.typ == ent.typ)
              oldLabel -> correctedLabel
            }
            rewriteOutputSchemaLabels(newSubselect, newLabels)
          case Some(newValuesExprs) =>
            Select(
              Distinctiveness.Indistinct(),
              selectList,
              Join(
                JoinType.Inner,
                true,
                FromStatement(
                  singleRowFrom match {
                    case None =>
                      Values(OrderedSet() ++ newValuesLabels, NonEmptySeq(newValuesExprs.map(_._1), Nil))
                    case Some(from) =>
                      Select(
                        Distinctiveness.Indistinct(),
                        OrderedMap() ++ newValuesLabels.lazyZip(newValuesExprs.toSeq).map { case (label, (expr, name)) =>
                          (label, NamedExpr(expr, name, hint = None, isSynthetic = true))
                        },
                        from,
                        None, Nil, None, Nil, None, None, None, Set.empty
                      )
                  },
                  valuesLabel,
                  valuesSource,
                  valuesCanonicalName,
                  None
                ),
                FromStatement(
                  newSubselect,
                  subselectLabel,
                  subselectSource,
                  subselectCanonicalName,
                  None
                ),
                trueExpr
              ),
              None,
              Nil,
              None,
              Nil,
              None,
              None,
              None,
              Set.empty
            )
        }
      case Select(
        distinctiveness,
        selectList,
        from,
        where,
        groupBy,
        having,
        orderBy,
        limit,
        offset,
        search,
        hint
      ) =>
        Select(
          rewriteDistinctiveness(distinctiveness, exprReplaces),
          selectList.withValuesMapped { ne => ne.copy(expr = rewriteExpr(ne.expr, exprReplaces)) },
          rewriteFrom(from, exprReplaces),
          where.map(rewriteExpr(_, exprReplaces)),
          groupBy.map(rewriteExpr(_, exprReplaces)),
          having.map(rewriteExpr(_, exprReplaces)),
          orderBy.map(rewriteOrderBy(_, exprReplaces)),
          limit,
          offset,
          search,
          hint
        )
    }
  }

  def rewriteOutputSchemaLabels(statement: Statement, map: Map[AutoColumnLabel, AutoColumnLabel]): Statement = {
    statement match {
      case s: Select =>
        s.copy(selectList = OrderedMap() ++ s.selectList.iterator.map { case (oldLabel, expr) => map(oldLabel) -> expr })
      case v: Values =>
        v.copy(labels = OrderedSet() ++ v.labels.iterator.map { oldLabel => map(oldLabel) })
      case cte: CTE =>
        cte.copy(useQuery = rewriteOutputSchemaLabels(cte.useQuery, map))
      case ct: CombinedTables =>
        ct.copy(left = rewriteOutputSchemaLabels(ct.left, map))
    }
  }

  def rewriteDistinctiveness(distinctiveness: Distinctiveness, exprReplaces: ExprReplaces): Distinctiveness =
    distinctiveness match {
      case Distinctiveness.Indistinct() | Distinctiveness.FullyDistinct() => distinctiveness
      case Distinctiveness.On(exprs) => Distinctiveness.On(exprs.map(rewriteExpr(_, exprReplaces)))
    }

  def rewriteFrom(from: From, exprReplaces: ExprReplaces): From =
    from.map[MT](
      rewriteAtomicFrom(_, exprReplaces),
      { (joinType, lateral, left, right, on) =>
        Join(joinType, lateral, left, rewriteAtomicFrom(right, exprReplaces), rewriteExpr(on, exprReplaces))
      }
    )

  def rewriteAtomicFrom(from: AtomicFrom, exprReplaces: ExprReplaces): AtomicFrom =
    from match {
      case t: FromTable => t
      case sr: FromSingleRow => sr
      case FromStatement(stmt, label, rn, cn, alias) => FromStatement(rewriteStatement(stmt, exprReplaces), label, rn, cn, alias)
      case c: FromCTE => c
    }

  def rewriteExpr(expr: Expr, exprReplaces: ExprReplaces): Expr =
    expr match {
      case vc@VirtualColumn(table, column, typ) =>
        exprReplaces.get((table, column)) match {
          case Some(replacement) =>
            assert(replacement.typ == typ)
            replacement.reReference(vc.position.reference)
          case None =>
            vc
        }
      case pt: PhysicalColumn =>
        pt
      case slr: SelectListReference =>
        slr
      case lit: Literal =>
        lit
      case fc@FunctionCall(func, args) =>
        FunctionCall(func, args.map(rewriteExpr(_, exprReplaces)))(fc.position)
      case afc@AggregateFunctionCall(func, args, distinct, filter) =>
        AggregateFunctionCall(
          func,
          args.map(rewriteExpr(_, exprReplaces)),
          distinct,
          filter.map(rewriteExpr(_, exprReplaces))
        )(afc.position)
      case wfc@WindowedFunctionCall(func, args, filter, partitionBy, orderBy, frame) =>
        WindowedFunctionCall(
          func,
          args.map(rewriteExpr(_, exprReplaces)),
          filter.map(rewriteExpr(_, exprReplaces)),
          partitionBy.map(rewriteExpr(_, exprReplaces)),
          orderBy.map(rewriteOrderBy(_, exprReplaces)),
          frame
        )(wfc.position)
    }

  def rewriteOrderBy(ob: OrderBy, exprReplaces: ExprReplaces) =
    ob.copy(expr = rewriteExpr(ob.expr, exprReplaces))
}

object InlineTrivialParameters {
  def apply[MT <: MetaTypes](isLiteralTrue: Expr[MT] => Boolean, stmt: Statement[MT]): Statement[MT] = {
    new InlineTrivialParameters[MT](isLiteralTrue).rewriteStatement(stmt, Map.empty)
  }
}
